INCOMING CHANGES SOON

- Add a NANDAB operator to bootstrap shift multiplication and other logic stuff

Notes: If I have to implement another VM operator im crashing out everywhere john pork style

Thats all for now i think stay tuned



oh also i need to implement strings of more than 8 characters using <> notation
^ probably should be done in an assembler directive?? idk man

FPRINT <i am a big string>
turns into
FPRINT "i am a b"
FPRINT "ig strin"
FPRINT "g"

ok ive been thinking and i think i need a $DUMP directive to put raw data and i can use <> to represent strings of more than 8 bytes, i really need to clean up a lot of the syntax and ways things are worked out

also on the chopping block due to the introduction of width: STAB and LDAB
with width STAB and LDAB are trivial to implement in about 2.5x space complexity, however this is acceptable due to how much space is being saved by width and how infrequently they are used relative to just STA and LDA


also also i need to update docs on endianness and make sure the vm specifics are covered especially for the example vm - im not even sure if the example vm is currently working i havent compiled it once lol

<uasmlib/math.uasm> would be goated
- multiplication
- division
- modulus

<uasmlib/float.uasm> would be insanely goated but horrifying to implement so thats later down the line once i have all my bitwise shit sorted out

<uasmlib/string.uasm> for strcmp, strlen, and general string management. need to think of a clever way to store strings in memory that doesnt require a void call every 8 bytes. possibly i implement some kind of malloc in stdlib but i have no idea where i would even attach that in program space. this is a problem for future me to deal with.
