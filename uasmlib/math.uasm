JMP _MATH_ENDLIB

.MACRO NOTA
CALL _MATH_NOTA
.ENMAC

_MATH_NOTA:
VOID 0
_MATH_NOTA_B:
VOID 0
STA64 _MATH_NOTA + 1
STB64 _MATH_NOTA_B + 1
LDB64 _MATH_NOTA + 1
NANDAB
LDB64 _MATH_NOTA_B + 1
RET

.MACRO SHL1A
CALL _MATH_SHL1A
.ENMAC

_MATH_SHL1A:
VOID 0
_MATH_SHL1A_B:
VOID 0
STA64 _MATH_SHL1A + 1
STB64 _MATH_SHL1A_B + 1
LDB64 _MATH_SHL1A + 1
ADDAB
LDB64 _MATH_SHL1A_B + 1
RET

; add a to addr
.MACRO ACCA addr
v0:
VOID 0
v1:
VOID %addr
STB64 v0 + 1
LDB64 v1 + 1
CALL _MATH_ACCA
LDB64 v0 + 1
.ENMAC

_MATH_ACCA:
VOID 0
_MATH_ACCA_ADDR:
VOID 0
STA64 _MATH_ACCA + 1
STB64 _MATH_ACCA_ADDR + 1
LDAB64
LDB64 _MATH_ACCA + 1
ADDAB
LDB64 _MATH_ACCA_ADDR + 1
STAB64
LDA64 _MATH_ACCA + 1
RET

.MACRO ANDAB
NANDAB
NOTA
.ENMAC

.MACRO SHRB v
SWP
SHRA %v
SWP
.ENMAC

.MACRO MULAB
CALL _MATH_MULAB
.ENMAC

_MATH_MULAB:
; initialize res acc and preserve b
VOID 0
_MATH_MULAB_CONST1:
VOID 1
_MATH_MULAB_RES:
VOID 0
_MATH_MULAB_B:
VOID 0
_MATH_MULAB_TEMP:
VOID 0
_MATH_MULAB_TEMP_B:
VOID 0
STB64 _MATH_MULAB_B + 1
LDB64 _MATH_MULAB + 1
STB64 _MATH_MULAB_RES + 1
LDB64 _MATH_MULAB_B + 1
; while b != 0
_MATH_MULAB_LOOP:
; if b & 1
; preserve a and b
STA64 _MATH_MULAB_TEMP + 1
STB64 _MATH_MULAB_TEMP_B + 1
; load 1 for & 1
LDA64 _MATH_MULAB_CONST1 + 1
; ANDBA
SWP
ANDAB
SWP
; restore a
LDA64 _MATH_MULAB_TEMP + 1
; b = b & 1
JMPBZ _MULAB_SKIP_ADD
; res = res + a
ACCA _MATH_MULAB_RES + 1
_MULAB_SKIP_ADD:
LDB64 _MATH_MULAB_TEMP_B + 1
; a = a << 1
SHL1A
; b = b >> 1
SHRB 1
JMPBZ _MATH_MULAB_DONE
JMP _MATH_MULAB_LOOP
_MATH_MULAB_DONE:
LDA64 _MATH_MULAB_RES + 1
LDB64 _MATH_MULAB_B + 1
RET

_MATH_ENDLIB:
