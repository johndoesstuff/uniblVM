JMP _MATH_ENDLIB

.MACRO NOTA
CALL _MATH_NOTA
.ENMAC

_MATH_NOTA:
VOID 0
_MATH_NOTA_B:
VOID 0
STA64 _MATH_NOTA + 1
STB64 _MATH_NOTA_B + 1
LDB64 _MATH_NOTA + 1
NANDAB
LDB64 _MATH_NOTA_B + 1
RET

.MACRO SHL1A
CALL _MATH_SHL1A
.ENMAC

_MATH_SHL1A:
VOID 0
_MATH_SHL1A_B:
VOID 0
STA64 _MATH_SHL1A + 1
STB64 _MATH_SHL1A_B + 1
LDB64 _MATH_SHL1A + 1
ADDAB
LDB64 _MATH_SHL1A_B + 1
RET

; add a to addr
.MACRO ACCA addr
v0:
VOID 0
v1:
VOID %addr
STB64 v0 + 1
LDB64 v1 + 1
CALL _MATH_ACCA
LDB64 v0 + 1
.ENMAC

_MATH_ACCA:
VOID 0
_MATH_ACCA_ADDR:
VOID 0
STA64 _MATH_ACCA + 1
STB64 _MATH_ACCA_ADDR + 1
LDAB64
LDB64 _MATH_ACCA + 1
ADDAB
LDB64 _MATH_ACCA_ADDR + 1
STAB64
LDA64 _MATH_ACCA + 1
RET

.MACRO ANDAB
NANDAB
NOTA
.ENMAC

.MACRO SHRB v
SWP
SHRA %v
SWP
.ENMAC

.MACRO MULAB
CALL _MATH_MULAB
.ENMAC

_MATH_MULAB:
; initialize res acc and preserve b
VOID 0
_MATH_MULAB_CONST1:
VOID 1
_MATH_MULAB_RES:
VOID 0
_MATH_MULAB_B:
VOID 0
_MATH_MULAB_TEMP:
VOID 0
_MATH_MULAB_TEMP_B:
VOID 0
STB64 _MATH_MULAB_B + 1
LDB64 _MATH_MULAB + 1
STB64 _MATH_MULAB_RES + 1
LDB64 _MATH_MULAB_B + 1
; while b != 0
_MATH_MULAB_LOOP:
; if b & 1
; preserve a and b
STA64 _MATH_MULAB_TEMP + 1
STB64 _MATH_MULAB_TEMP_B + 1
; load 1 for & 1
LDA64 _MATH_MULAB_CONST1 + 1
; ANDBA
SWP
ANDAB
SWP
; restore a
LDA64 _MATH_MULAB_TEMP + 1
; b = b & 1
JMPBZ _MULAB_SKIP_ADD
; res = res + a
ACCA _MATH_MULAB_RES + 1
_MULAB_SKIP_ADD:
LDB64 _MATH_MULAB_TEMP_B + 1
; a = a << 1
SHL1A
; b = b >> 1
SHRB 1
JMPBZ _MATH_MULAB_DONE
JMP _MATH_MULAB_LOOP
_MATH_MULAB_DONE:
LDA64 _MATH_MULAB_RES + 1
LDB64 _MATH_MULAB_B + 1
RET

.MACRO DIVAB
CALL _MATH_DIVAB
.ENMAC

_MATH_DIVAB:
_MATH_DIVAB_A:
VOID 0
_MATH_DIVAB_B:
VOID 0
_MATH_DIVAB_QUOTIENT:
VOID 0
_MATH_DIVAB_QUOTIENT_MASK:
VOID 0
_MATH_DIVAB_QUOTIENT_MASK_INIT:
VOID 0x8000000000000000
_MATH_DIVAB_REMAINDER:
VOID 0
_MATH_DIVAB_I:
VOID 0
_MATH_DIVAB_I_INIT:
VOID 63
_MATH_DIVAB_1:
VOID 1
_MATH_DIVAB_0:
VOID 0
; preserve a and b
STA64 _MATH_DIVAB_A + 1
STB64 _MATH_DIVAB_B + 1
; initialize
LDA64 _MATH_DIVAB_I_INIT + 1
STA64 _MATH_DIVAB_I + 1
LDA64 _MATH_DIVAB_0 + 1
STA64 _MATH_DIVAB_QUOTIENT + 1
STA64 _MATH_DIVAB_REMAINDER + 1
LDA64 _MATH_DIVAB_QUOTIENT_MASK_INIT + 1
STA64 _MATH_DIVAB_QUOTIENT_MASK + 1
; main loop
_MATH_DIVAB_LOOP:
PRINTA
PRINTN
PRINTB
PRINTN
; left shift remainder
LDA64 _MATH_DIVAB_REMAINDER + 1
SHL1A
STA64 _MATH_DIVAB_REMAINDER + 1
; get bit i of numerator (a)
LDA64 _MATH_DIVAB_I + 1
STA 0, _MATH_DIVAB_SHRA + 1, 1
LDA64 _MATH_DIVAB_A + 1
_MATH_DIVAB_SHRA:
SHRA 0
LDB64 _MATH_DIVAB_1 + 1
ANDAB
; set lsb of remainder to bit i of num
ACCA _MATH_DIVAB_REMAINDER + 1
; if remainder >= divisor (b)
LDA64 _MATH_DIVAB_B + 1
LDB64 _MATH_DIVAB_REMAINDER + 1
SUBAB
SWP
; b = divisor - remainder
JMPBZ _MATH_DIVAB_SKIP_IF
; remainder = remainder - divisor
; a = remainder
LDB64 _MATH_DIVAB_B + 1
SUBAB
STA64 _MATH_DIVAB_REMAINDER + 1
; quotient += quotient mask
LDA64 _MATH_DIVAB_QUOTIENT + 1
LDB64 _MATH_DIVAB_QUOTIENT_MASK + 1
ADDAB
STA64 _MATH_DIVAB_QUOTIENT + 1
; inc quotient mask
_MATH_DIVAB_SKIP_IF:
LDA64 _MATH_DIVAB_QUOTIENT_MASK + 1
SHRA 1
STA64 _MATH_DIVAB_QUOTIENT_MASK + 1
; dec i
LDA64 _MATH_DIVAB_I + 1
LDB64 _MATH_DIVAB_1 + 1
SUBAB
STA64 _MATH_DIVAB_I + 1
SWP
; break if i = 0
JMPBZ _MATH_DIVAB_DONE
JMP _MATH_DIVAB_LOOP
_MATH_DIVAB_DONE:
LDA64 _MATH_DIVAB_QUOTIENT + 1
LDB64 _MATH_DIVAB_REMAINDER + 1
RET

_MATH_ENDLIB:
