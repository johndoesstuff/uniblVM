JMP _PRINT_ENDLIB

.MACRO INC_P_STDOUT
v:
VOID 0
LDA64 v + 1
LDA 0, P_STDOUT, 2
INCA16
STA P_STDOUT, 0, 2
.ENMAC

.MACRO PUTA8
CALL _PRINT_PUTA8
.ENMAC

_PRINT_PUTA8:
_PRINT_PUTA8_A:
VOID 0
_PRINT_PUTA8_B:
VOID 0
_PRINT_PUTA8_STDOUT_FLUSH:
VOID STDOUT_FLUSH
STA64 _PRINT_PUTA8_A + 1
STB64 _PRINT_PUTA8_B + 1
; load stack pointer to B
SETBZ
LDB16 P_STDOUT
; set *sp to A
STB64 put_sta + 1
put_sta:
STA 0, 0, 1
; inc B by 1 (8bit addr width)
SWP
INCA16
SWP
; restore incremented stack pointer
STB16 P_STDOUT
; check if end of stdout is reached
LDA64 _PRINT_PUTA8_STDOUT_FLUSH + 1
CMPAB
JMPBNZ _PRINT_PUTA8_SKIP_FLUSH
; flush output
; set STDOUT_FLUSH flag to 1
SETA1
STA STDOUT_FLUSH, 0, 1
; set P_STDOUT to STDOUT
_PRINT_PUTA8_STDOUT:
VOID STDOUT
LDA64 _PRINT_PUTA8_STDOUT + 1
STA16 P_STDOUT
_PRINT_PUTA8_SKIP_FLUSH:
; restore state of B
LDA64 _PRINT_PUTA8_A + 1
LDB64 _PRINT_PUTA8_B + 1
RET

.MACRO PRINTA
CALL _PRINT_PRINTA
.ENMAC

_PRINT_PRINTA:
JMP _PRINT_PRINTA_DIGIT_MASK
_PRINT_PRINTA_DIGITS:
$DUMP <0123456789ABCDEF>
_PRINT_PRINTA_DIGIT_MASK:
VOID 0
_PRINT_PRINTA_DIGIT_MASK_INIT:
VOID 0xF000000000000000
_PRINT_PRINTA_I:
VOID 0
_PRINT_PRINTA_I_INIT:
VOID 60
_PRINT_PRINTA_DIGIT:
VOID 0
_PRINT_PRINTA_TEMP:
VOID 0
_PRINT_PRINTA_A:
VOID 0
_PRINT_PRINTA_B:
VOID 0
_PRINT_PRINTA_4:
VOID 4
_PRINT_PRINTA_FINAL:
VOID 0
_PRINT_PRINTA_0:
VOID 0
_PRINT_PRINTA_PREFIX:
VOID "0x"
STA64 _PRINT_PRINTA_A + 1
STB64 _PRINT_PRINTA_B + 1
STA64 _PRINT_PRINTA_TEMP + 1
; prefix "0x"
LDA 0, _PRINT_PRINTA_PREFIX + 1, 1
PUTA8
LDA 0, _PRINT_PRINTA_PREFIX + 2, 1
PUTA8
; init
LDA64 _PRINT_PRINTA_DIGIT_MASK_INIT + 1
STA64 _PRINT_PRINTA_DIGIT_MASK + 1
LDA64 _PRINT_PRINTA_I_INIT + 1
STA64 _PRINT_PRINTA_I + 1
; final runs the loop an extra time, must not be 0
LDA64 _PRINT_PRINTA_4 + 1
STA64 _PRINT_PRINTA_FINAL + 1
_PRINT_PRINTA_LOOP:
; get digits
LDA64 _PRINT_PRINTA_I + 1
STA _PRINT_PRINTA_SHRA + 1, 0, 1
LDA64 _PRINT_PRINTA_A + 1
LDB64 _PRINT_PRINTA_DIGIT_MASK + 1
ANDAB
; shift digits by i to first index
_PRINT_PRINTA_SHRA:
SHRA 0
; b = digit val
SWP
; offset pointer
_PRINT_PRINTA_DIGITS_P:
VOID _PRINT_PRINTA_DIGITS
LDA64 _PRINT_PRINTA_DIGITS_P + 1
ADDAB
SWP
; ascii code of digit
STB64 _PRINT_PRINTA_LDA + 2
_PRINT_PRINTA_LDA:
LDA 0, 0, 1
; print ascii of digit
PUTA8
; if on final digit short circuit
LDA64 _PRINT_PRINTA_FINAL + 1
SWP
JMPBZ _PRINT_PRINTA_DONE
; shr mask
LDA64 _PRINT_PRINTA_DIGIT_MASK + 1
SHRA 4
STA64 _PRINT_PRINTA_DIGIT_MASK + 1
; dec i 4
LDB64 _PRINT_PRINTA_4 + 1
LDA64 _PRINT_PRINTA_I + 1
SUBAB
STA64 _PRINT_PRINTA_I + 1
; break b == 0
SWP
JMPBZ _PRINT_PRINTA_SET_FINAL
JMP _PRINT_PRINTA_LOOP
_PRINT_PRINTA_SET_FINAL:
LDA64 _PRINT_PRINTA_0 + 1
STA64 _PRINT_PRINTA_FINAL + 1
JMP _PRINT_PRINTA_LOOP
_PRINT_PRINTA_DONE:
LDA64 _PRINT_PRINTA_A + 1
LDB64 _PRINT_PRINTA_B + 1
RET

.MACRO PRINTN
v:
VOID 10
a:
VOID 0
STA64 a + 1
LDA64 v + 1
PUTA8
LDA64 a + 1
.ENMAC

.MACRO PRINTB
SWP
PRINTA
SWP
.ENMAC

.MACRO PRINT str
STA64 _PRINT_PRINT_A + 1
_p:
VOID %str
LDA64 _p + 1
CALL _PRINT_PRINT
.ENMAC

_PRINT_PRINT:
_PRINT_PRINT_A:
VOID 0
PUTA8
SHRA 1
PUTA8
SHRA 1
PUTA8
SHRA 1
PUTA8
SHRA 1
PUTA8
SHRA 1
PUTA8
SHRA 1
PUTA8
SHRA 1
PUTA8
LDA64 _PRINT_PRINT_A + 1
RET

_PRINT_ENDLIB:
