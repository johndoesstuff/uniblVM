ENTRY_POINT:

$INCLUDE <uasmlib/stdlib_macros.uasm>

$DEF CALLSTACK_SIZE 0x400
$DEF STACK_SIZE 0xC00

$DEF CALLSTACK 0x0800
$DEF STACK CALLSTACK + CALLSTACK_SIZE
$DEF P_STDIN STACK + STACK_SIZE
$DEF P_STDOUT P_STDIN + 2
$DEF P_CALLSTACK P_STDOUT + 2
$DEF P_STACK P_CALLSTACK + 2
; STDLIB Memory
; Entry: 0x0800
; Callstack: 0x0800 - 0x0BFF
; Stack: 0x0C00 - 0x17FF
; *STDIN: 0x1800 - 0x1801
; *STDOUT: 0x1802 - 0x1803
; *Callstack: 0x1804 - 0x1805
; *Stack: 0x1806 - 0x1807
; Reserved: 0x1808 - 0x18FF

$DEF TEMP 0x1900
; Temp memory for critical macros
$DEF TEMP_INC TEMP
$DEF TEMP_INC_ADDR TEMP + 8
$DEF TEMP_PUSH TEMP_INC_ADDR + 8
$DEF TEMP_SET TEMP_PUSH + 8
$DEF TEMP_CALL TEMP_SET + 8
$DEF TEMP_RET TEMP_CALL + 16
$DEF TEMP_PUT TEMP_RET + 16

$DEF RETURN 0x0000
; 0x0000 = Return Code

; Jump ahead to clear memory for call stack, stack and temp
JMP TEMP + 0x0100
$PC TEMP + 0x0100

; Initialize Pointers
SET16 P_STDIN, 0x000
SET16 P_STDOUT, 0x400
SET16 P_CALLSTACK, CALLSTACK
SET16 P_STACK, STACK

JMP _STDLIB_ENDLIB

_STDLIB_RET:
; save
STA64 TEMP_RET
STB64 TEMP_RET + 8
; load csp
SETBZ
LDB16 P_CALLSTACK
; dec csp
DEC8B16
; load address from csp
LDAB64
STB16 P_CALLSTACK
; goto a
LDB64 TEMP_RET + 8
; jmpa but preserve a
STA64 _STDLIB_RET_JMP + 1
LDA64 TEMP_RET
_STDLIB_RET_JMP:
JMP 0

_STDLIB_CALL:
; preserve B
STB64 TEMP_CALL + 8

SETBZ
; load csp into B
LDB16 P_CALLSTACK
; store A at csp
STAB64
; inc csp
INC8B16
STB16 P_CALLSTACK
; get addr (ldpca - 1)
SWP
SETAV16 17
SWP
SUBAB
SWP
LDAB64
STA64 _STDLIB_CALL_JMP + 1
LDA64 TEMP_CALL
LDB64 TEMP_CALL + 8
_STDLIB_CALL_JMP:
JMP 0

_STDLIB_ENDLIB:
