ENTRY_POINT:

; 64 Bit storage macros
.MACRO LDA64 x
LDA 7, %x
LDA 6, %x + 1
LDA 5, %x + 2
LDA 4, %x + 3
LDA 3, %x + 4
LDA 2, %x + 5
LDA 1, %x + 6
LDA 0, %x + 7
.ENMAC

.MACRO LDA64R x
LDA 0, %x
LDA 1, %x + 1
LDA 2, %x + 2
LDA 3, %x + 3
LDA 4, %x + 4
LDA 5, %x + 5
LDA 6, %x + 6
LDA 7, %x + 7
.ENMAC

.MACRO LDB64 x
SWP
LDA64 %x
SWP
.ENMAC

.MACRO LDB64R x
SWP
LDA64R %x
SWP
.ENMAC

.MACRO STA64 x
STA %x, 7
STA %x + 1, 6
STA %x + 2, 5
STA %x + 3, 4
STA %x + 4, 3
STA %x + 5, 2
STA %x + 6, 1
STA %x + 7, 0
.ENMAC

.MACRO STA64R x
STA %x, 0
STA %x + 1, 1
STA %x + 2, 2
STA %x + 3, 3
STA %x + 4, 4
STA %x + 5, 5
STA %x + 6, 6
STA %x + 7, 7
.ENMAC

.MACRO STB64 x
SWP
STA64 %x
SWP
.ENMAC

.MACRO STB64R x
SWP
STA64R %x
SWP
.ENMAC

; 16 Bit storage macros
.MACRO LDA16 x
LDA 1, %x
LDA 0, %x + 1
.ENMAC

.MACRO LDB16 x
SWP
LDA16 %x
SWP
.ENMAC

.MACRO STA16 x
STA %x, 1
STA %x + 1, 0
.ENMAC

.MACRO STB16 x
SWP
STA16 %x
SWP
.ENMAC

; General purpose macros
.MACRO LDB x, y
SWP
LDA %x, %y
SWP
.ENMAC

.MACRO STB x, y
SWP
STA %x, %y
SWP
.ENMAC

; Set B to 0
.MACRO SETBZ
CMPAB
v:
VOID 0
LDB 0, v + 1
.ENMAC

; Set A and B to 0
.MACRO SETABZ
CMPAB
SWP
CMPAB
v:
VOID 0
LDA 0, v + 1
SWP
LDA 0, v + 1
.ENMAC

; Set B to 1
.MACRO SETB1
CMPAB
v:
VOID 1
LDB 0, v + 8
.ENMAC

.MACRO SETA1
SWP
SETB1
SWP
.ENMAC

.MACRO FJMP addr
SETBZ
JMPBZ %addr
.ENMAC

.MACRO CALL addr
LDPCA
.ENMAC

.MACRO STAB64
STAB
.ENMAC

.MACRO INCA64
STB64 TEMP_INC
SETB1
ADDAB
LDB64 TEMP_INC
.ENMAC

.MACRO INC8A64
STB64 TEMP_INC
SETB1
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
LDB64 TEMP_INC
.ENMAC

.MACRO INCB64
SWP
INCA64
SWP
.ENMAC

.MACRO INC8B64
SWP
INC8A64
SWP
.ENMAC

.MACRO INCA16
STB16 TEMP_INC
SETB1
ADDAB
LDB16 TEMP_INC
.ENMAC

.MACRO INC8A16
STB16 TEMP_INC
SETB1
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
ADDAB
LDB16 TEMP_INC
.ENMAC

.MACRO INCB16
SWP
INCA16
SWP
.ENMAC

.MACRO INC8B16
SWP
INC8A16
SWP
.ENMAC

.MACRO SET64 addr, val
; save state
STA64 TEMP_SET
v:
VOID %val
; set A to value
LDA64 v+1
; set addr to a
STA64 %addr
; reset state
LDA64 TEMP_SET
.ENMAC

.MACRO PUSHA
; save state of B
STB64 TEMP_PUSH
; load stack pointer to B
SETBZ
LDB16 P_STACK
; set *sp to A
STAB64
; inc B by 8 (64bit addr width)
INC8B16
; restore incremented stack pointer
STB16 P_STACK
; restore state of B
LDB64 TEMP_PUSH
.ENMAC

$DEF CALLSTACK_SIZE 0x400
$DEF STACK_SIZE 0xC00

$DEF CALLSTACK 0x0800
$DEF STACK CALLSTACK + CALLSTACK_SIZE
$DEF P_STDIN STACK + STACK_SIZE
$DEF P_STDOUT P_STDIN + 2
$DEF P_CALLSTACK P_STDOUT + 2
$DEF P_STACK P_CALLSTACK + 2
; STDLIB Memory
; Entry: 0x0800
; Callstack: 0x0800 - 0x0BFF
; Stack: 0x0C00 - 0x17FF
; *STDIN: 0x1800 - 0x1801
; *STDOUT: 0x1802 - 0x1803
; *Callstack: 0x1804 - 0x1805
; *Stack: 0x1806 - 0x1807
; Reserved: 0x1808 - 0x18FF

$DEF TEMP 0x1900
; Temp memory for critical macros
$DEF TEMP_INC TEMP
$DEF TEMP_INC_ADDR TEMP + 8
$DEF TEMP_PUSH TEMP_INC_ADDR + 8
$DEF TEMP_SET TEMP_PUSH + 8
$DEF TEMP_STAB64 TEMP_SET + 8

$DEF RETURN 0x0000
; 0x0000 = Return Code

; Jump ahead to clear memory for call stack, stack and temp
; Round up to nearest 0x0100
VOID TEMP + 0x0100
_CSLDA:
LDA 1, ENTRY_POINT + 7
_CSJMPA:
JMPA

$PC 0x1A00

; Set Callstack to 0
SWP
STA CALLSTACK, 0
STA _CSLDA, 0
STA _CSLDA + 1, 0
STA _CSLDA + 8, 0
STA _CSLDA + 9, 0
STA _CSJMPA, 0

; Initialize Pointers
SET64 P_STDOUT, 0x400

SIZEOF:
STAB64
ESIZEOF:
$DEBUG ESIZEOF-SIZEOF
